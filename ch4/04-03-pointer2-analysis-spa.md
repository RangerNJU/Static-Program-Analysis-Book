# æŒ‡é’ˆåˆ†æç†è®ºåŸºç¡€

## æŒ‡é’ˆåˆ†æç†è®ºåŸºç¡€

æœ¬æ–‡å°†ä¸»è¦ä»‹ç»ä»¥ä¸‹å››ç‚¹å†…å®¹ã€‚å‰ä¸‰ç‚¹å¯¹åº”çº¿ä¸‹è¯¾ç¨‹ç¬¬ä¹è¯¾ï¼Œæœ€åä¸€ç‚¹å¯¹åº”ç¬¬åè¯¾ã€‚

1. Pointer Analysis: Rules
2. How to Implement Pointer Analysis
3. Pointer Analysis: Algorithms
4. Pointer Analysis with Method Calls

## Notations

![](../.gitbook/assets/image-20201105195029800.png)

é¦–å…ˆä»‹ç»å¸¸ç”¨æ•°å­¦ç¬¦å·ï¼Œä¸ä¼šçš„åŒå­¦å¯ä»¥å¤ä¹ ä¸€ä¸‹ç¦»æ•£æ•°å­¦ã€‚

![](../.gitbook/assets/image-20201105195154527.png)

åˆ†åˆ«å®šä¹‰å˜é‡ï¼ŒåŸŸï¼Œå¯¹è±¡ï¼ˆç”¨ä¸‹æ ‡æ ‡è¯†æ˜¯åœ¨ç¬¬å‡ è¡Œåˆ›å»ºçš„å¯¹è±¡ï¼‰ï¼Œå®ä¾‹åŸŸå’ŒæŒ‡é’ˆï¼ˆæ˜¯å˜é‡å’Œå®ä¾‹å¯¹è±¡çš„å¹¶ï¼‰ï¼Œå’ŒæŒ‡å‘å…³ç³»ã€‚`X`è¡¨ç¤ºç¬›å¡å°”ç§¯ã€‚

pt\(p\)ä»£è¡¨çš„æ˜¯æŒ‡é’ˆpå¯èƒ½æŒ‡å‘çš„å¯¹è±¡ã€‚å¦‚åœ¨ä¸‹é¢çš„ä»£ç å—åï¼Œpt\(x\)å¯èƒ½æŒ‡å‘çš„ç›®æ ‡å¯ä»¥è®°ä¸º$${o_2,o_4}$$ï¼ˆä»¥è¡Œå·ä½œä¸ºobjectçš„ä¸‹æ ‡ï¼‰ã€‚

```java
if(...){
    x = new A();
} else {
    x = new B();
}
```

## Pointer Analysis: Rules

_å‰æ’æç¤ºï¼šä¸ã€Šæ•°ç†é€»è¾‘ã€‹/ã€Šå½¢å¼åŒ–è¯­ä¹‰ã€‹æ¢¦å¹»è”åŠ¨ã€‚æ²¡å­¦è¿‡çš„åŒå­¦ä¹Ÿä¸è¦ç€æ€¥ã€‚_

![](../.gitbook/assets/image-20201105195524932.png)

ä¸»è¦è§£é‡ŠRuleä¸€åˆ—ä¸­çš„å†…å®¹ã€‚**æ¨ªçº¿ä¸Šçš„å†…å®¹æ˜¯å‰æ\(Premises\)ï¼Œæ¨ªçº¿ä¸‹çš„å†…å®¹æ˜¯ç»“è®º\(Conclusion\)ã€‚**

ç”¨ç®€å•æ˜“æ‡‚çš„è¯­è¨€æè¿°ï¼Œçœ‹åˆ°newè¯­å¥ï¼Œæˆ‘ä»¬å°±å°†æ–°å»ºçš„å¯¹è±¡åŠ å…¥`pt(x)`ã€‚

![](../.gitbook/assets/image-20201105195943007.png)

å¯¹äºAssignè¯­å¥ï¼Œæˆ‘ä»¬å°†xæŒ‡å‘yæŒ‡å‘çš„å¯¹è±¡ã€‚

![](../.gitbook/assets/image-20201105235312349.png)

å¯¹äºStoreå’ŒLoadäº¦ç„¶ã€‚

![](../.gitbook/assets/image-20201105200112512.png)

![](../.gitbook/assets/image-20201105200123601.png)

### Summary

æœ€åç”¨ä¸€å›¾æ€»ç»“ã€‚**ç¬¬ä¸€æ¡è§„åˆ™æ·»åŠ æŒ‡å‘ï¼Œè€Œåä¸‰æ¡è§„åˆ™ä¼ é€’æŒ‡å‘å…³ç³»ã€‚**

![](../.gitbook/assets/image-20201105200412145.png)

## How to Implement Pointer Analysis

_åˆ«å¤„çš„èµ„æ–™éƒ½æ²¡æœ‰å…¨å®¶æ¡¶ï¼Œåªä»‹ç»æŸäº›ç‰¹æ®Šæƒ…å†µä¸‹çš„åˆ†æç®—æ³•ã€‚åœ¨è¿™é‡Œä½ èƒ½å–œæä¸€ä¸ªå®Œæ•´çš„æŒ‡é’ˆåˆ†æç®—æ³•å…¨å®¶æ¡¶ã€‚_

æœ¬è´¨ä¸Šæ¥è¯´ï¼ŒæŒ‡é’ˆåˆ†ææ˜¯åœ¨æŒ‡é’ˆé—´**ä¼ é€’**æŒ‡å‘å…³ç³»ã€‚

![](../.gitbook/assets/image-20201105200815104.png)

inclusion constraintsçš„å…·ä½“è§£é‡Šï¼šåœ¨ä¸Šè¿°è¡¨ç¤ºçš„ç»“è®ºéƒ¨åˆ†ä¸­å¯ä»¥å†™ä½œä¸¤ä¸ªé›†åˆé—´çš„åŒ…å«å…³ç³»ã€‚å¦‚Loadåº”è¯¥è¡¨ç¤ºä¸ºï¼š

* å‰æï¼š`y=x.f`å’Œ $$o_i \in pt(x)$$
* ç»“è®ºï¼š$$pt(o_i.f) \subset pt(y)$$

> Key to implementation: when ğ‘ğ‘¡\(ğ‘¥\)is **changed**, **propagate** the **changed par**t to the **related pointers** of ğ‘¥

![](../.gitbook/assets/image-20201105201018655.png)

### Pointer Flow Graph

> Pointer Flow Graph \(PFG\) of a program is a directed graph  
> that expresses how objects flow among the pointers in the program.

ä¸ºäº†å®ç°æŒ‡é’ˆåˆ†æï¼Œæˆ‘ä»¬é¦–å…ˆäº†è§£ä¸ä¹‹å¯†åˆ‡ç›¸å…³çš„æ•°æ®ç»“æ„â€”â€”æŒ‡é’ˆæµå›¾ã€‚

å›¾çš„ä¸¤å¤§è¦ç´ æ˜¯Nodeå’ŒEdgeã€‚æˆ‘ä»¬å®šä¹‰ï¼š

* `Node: Pointer = V â‹ƒ (O Ã— F)`
  * A node n represents **a variable** or **a field of an abstract object**
* `Edges: Pointer Ã— Pointer`
  * **An edge ğ‘¥ -&gt; ğ‘¦** means that the objects pointed by pointer ğ‘¥ **may flow to \(and also be pointed to by\)** pointer ğ‘¦

![](../.gitbook/assets/image-20201105201421501.png)

### Example

å‡è®¾cå’Œdä¸€å¼€å§‹éƒ½æŒ‡å‘ $$o_i$$ï¼Œæ ¹æ®ä¸Šè¿°è§„åˆ™ï¼Œæˆ‘ä»¬èƒ½å¤Ÿä»å·¦ä¾§çš„ç¨‹åºè¯­å¥ä»ä¸Šåˆ°ä¸‹æ„å»ºå‡ºå³ä¾§çš„æŒ‡é’ˆæµå›¾ã€‚

![](../.gitbook/assets/image-20201105201746860.png)

å› æ­¤ï¼Œæ‰€æœ‰bæ‰€æŒ‡å‘çš„å¯¹è±¡æ›´æ–°æ—¶ï¼Œéƒ½è¦ä¼ é€’åˆ°eä¸­ã€‚è¿™æ˜¯ä¸€ä¸ªæ±‚ä¼ é€’é—­åŒ…\(transitive closure\)çš„è¿‡ç¨‹ã€‚å‡å¦‚æˆ‘ä»¬è€ƒè™‘jä½ç½®çš„ä¸€æ¡æ–°è¯­å¥`b = new T();`

![](../.gitbook/assets/image-20201105201939088.png)

PFGçš„æ•´ä¸ªæ„é€ è¿‡ç¨‹ï¼Œéœ€è¦åœ¨æ„å»ºPFGå’Œåœ¨å·²æœ‰çš„PFGä¸Šä¼ é€’æŒ‡å‘å…³ç³»è¿™ä¸¤ä¸ªæ­¥éª¤é—´å¾ªç¯å¾€å¤ã€‚è¿™ä¸¤ä¸ªæ­¥éª¤æ˜¯ç›¸äº’ä¾èµ–çš„ï¼Œæ‰€ä»¥éœ€è¦ç²¾å¿ƒè®¾è®¡ç®—æ³•æ¥å®ç°åˆ†æã€‚

![](../.gitbook/assets/image-20201105202101633.png)

## Pointer Analysis: Algorithms

### Introduction to algorithm

* ç”±äºåšæµä¸æ•æ„Ÿåˆ†æã€‚è¾“å…¥ä¸ºSetï¼Œä¸¢å¤±äº†è¯­å¥çš„é¡ºåºå…³ç³»ä¹Ÿæ²¡å…³ç³»ã€‚
* WorkListï¼šä¿å­˜æ¥ä¸‹æ¥è¦å¤„ç†çš„æŒ‡å‘ä¿¡æ¯ï¼Œä¸BFSä¸­çš„é˜Ÿåˆ—ä½œç”¨ç±»ä¼¼ã€‚
  * Each worklist entry ğ‘›, ğ‘ğ‘¡ğ‘  is a pair of pointer ğ‘› and points-to set ğ‘ğ‘¡ğ‘ , which means that ğ‘ğ‘¡ğ‘  should be propagated to ğ‘ğ‘¡\(ğ‘›\)
  * E.g.,  $$[(x,\{o_i\}),(y,\{o_j, o_k\}),(x.f,\{(o_l)\}),\dots]$$

é¦–å…ˆï¼Œå››ä¸ªçº¢æ¡†éƒ¨åˆ†å¯¹åº”ä¹‹å‰æåˆ°çš„å››ç§åŸºæœ¬è¯­å¥â€”â€”Newã€Assignã€Storeå’ŒLoadã€‚æ¥ä¸‹æ¥åšè¯¦ç»†è®²è§£ã€‚

![](../.gitbook/assets/image-20201127170432941.png)

### Handling of New and Assign

#### Init and adding edges

![](../.gitbook/assets/image-20201112191544354.png)

é¦–å…ˆè€ƒè™‘ä¸¤ç§ç®€å•çš„è¯­å¥ï¼šNewå’ŒAssignã€‚

* å‰ä¸‰è¡Œä»£ç åšåˆå§‹åŒ–çš„å·¥ä½œï¼Œå¹¶é’ˆå¯¹æ‰€æœ‰çš„**New**è¯­å¥ï¼Œå°†æ‰€æœ‰çš„åˆå§‹æŒ‡å‘å…³ç³»åŠ å…¥WorkListã€‚
* ä¹‹åçš„ä¸¤è¡Œä»£ç å¤„ç†**Assign**è¯­å¥ï¼Œæ·»åŠ `y->x`çš„è¾¹åˆ°PFGä¸­ã€‚æ·»åŠ è¾¹çš„å…·ä½“ç®—æ³•å¦‚ä¸‹

![](../.gitbook/assets/image-20201112191630283.png)

#### Propagate

![](../.gitbook/assets/image-20201112193329365.png)

ä¼ æ’­çš„å…·ä½“ç®—æ³•å¦‚ä¸‹ï¼Œæ ‡å·ä¸º2çš„è¯­å¥æ˜¯æ•´ä¸ªç®—æ³•ä¸­å”¯ä¸€æ‰§è¡Œåæ”¹å˜æŒ‡å‘å…³ç³»çš„è¯­å¥ã€‚

![](../.gitbook/assets/image-20201112193357268.png)

#### Detial-Differential Propagation

åœ¨çœŸå®çš„æŒ‡é’ˆåˆ†æä¸­ï¼Œå¯¹è±¡çš„æ•°é‡éå¸¸å·¨å¤§ï¼ˆä¸Šäº¿ï¼‰ï¼Œæˆ‘ä»¬é€šè¿‡Differential Propagationæ¥æ¶ˆé™¤å†—ä½™ã€‚

```cpp
Solve(ğ‘†)
    ...
    while WL is not empty do
        remove ğ‘›, ğ‘ğ‘¡ğ‘  from WL
        Î” = pts â€“ pt(n) // Differential Propagation
        Propagate(n, Î”) // Differential Propagation
```

é¦–å…ˆæˆ‘ä»¬è€ƒè™‘ä¸ä½¿ç”¨Differential Propagationçš„æƒ…å†µï¼Œé¦–å…ˆæ˜¯a-&gt;c-&gt;dçš„ä¼ é€’è·¯çº¿ã€‚

![](../.gitbook/assets/image-20201112194234928.png)

ç„¶åæ˜¯b-&gt;c-&gt;dçš„ä¼ é€’è·¯çº¿ï¼Œè™½ç„¶ $$\{o_1, o_3\}$$ä¹‹å‰å·²ç»åœ¨cæ‰€æŒ‡å‘çš„é›†åˆä¸­äº†ï¼Œä½†ä¾ç„¶éœ€è¦å‚ä¸ä¼ æ’­ï¼Œè¿™æ˜¯å†—ä½™çš„ã€‚

![](../.gitbook/assets/image-20201112194358502.png)

æˆ‘ä»¬å†æ¥çœ‹ä½¿ç”¨Differential Propagationçš„æƒ…å†µï¼Œåªéœ€è¦ä¼ æ’­$$\{o_5\}$$ä¸€é¡¹å³å¯ã€‚åœ¨å®é™…åº”ç”¨ä¸­è¿™èƒ½å¤Ÿå¤§å¤§å‡å°å¼€é”€ã€‚

![](../.gitbook/assets/image-20201112194555582.png)

* In practice, Î” is usually small compared with the original set, so propagating only the new points-to information \(Î”\) 
* Besides, Î” is also important for efficiency when handling stores, loads, and method calls, as explained later

### Handling Store and Load

![](../.gitbook/assets/image-20201112195502575.png)

å¯¹äºAddEdgeå‡½æ•°ä¸­ç¬¬äºŒä¸ªifçš„è¯´æ˜ï¼šä»…åœ¨ç¬¬ä¸€æ¬¡æ·»åŠ s-&gt;tåˆ°PFGæ—¶æ·»åŠ pt\(s\)çš„ä¿¡æ¯åˆ°tï¼Œæ˜¯å› ä¸ºPropagateä¸­çš„è¯­å¥èƒ½å¤Ÿå¤„ç†åç»­çš„pt\(s\)å˜åŒ–ã€‚

### The Algorithm-Review

è‡³æ­¤ï¼Œæˆ‘ä»¬å®Œæ•´åœ°ä»‹ç»äº†ä¸ºäº†æ•™å­¦ç›®çš„è®¾è®¡çš„æŒ‡é’ˆåˆ†æç®—æ³•ã€‚

![](../.gitbook/assets/image-20201123205009821.png)

### Example

**å°è¯•ç”¨ä¸Šè¿°ç®—æ³•ï¼Œè®¡ç®—ä»¥ä¸‹ä»£ç çš„PFGã€‚**

```java
b = new C();
a = b;
c = new C();
c.f = a;
d = c;
c.f = d;
e = d.f;
```

è¿™ä¸€ä¾‹å­åŠ¨æ€å†…å®¹å¾ˆå¤šï¼Œæ‰€ä»¥è®¡åˆ’å½•åˆ¶ä¸€å°æ®µè§†é¢‘è®²è§£ã€‚å…ˆæ”¾ä¸ªç­”æ¡ˆï¼Œèƒ½è‡ªå·±æ¨å¯¼å¯¹çš„åŒå­¦å°±å¯ä»¥è·³è¿‡è§†é¢‘äº†ã€‚

![](../.gitbook/assets/image-20201126221950557.png)

## Key points

**The X You Need To Understand in This Lecture**

* **Rules** for pointer analysis 
* **PFG**\(Pointer flow graph\)
* **Algorithm** for pointer analysis 

**ä»¥ä¸‹å†…å®¹å¯¹åº”ç¬¬10è¯¾ã€‚**

æ¥ä¸‹æ¥æˆ‘ä»¬å­¦ä¹ ç”¨æŒ‡é’ˆåˆ†æçš„æ–¹å¼æ¥æ„å»ºCall graphï¼Œé¦–å…ˆå¯¹æ¯”ä»¥ä¸‹CHAå’ŒæŒ‡é’ˆåˆ†æä¸¤ç§æ–¹æ³•ï¼š

* CHA: imprecise, introduce spurious call graph edges and points-to relations
* Pointer analysis: more precise than CHA, both for call graph and points-to relations\(a.k.a on-the-fly call graph construction\)

## Pointer Analysis with Method Calls

æœ¬è¯¾å°†ç»™å‡ºä¸€ä¸ªåŒ…å«å‡½æ•°é—´åˆ†æçš„é€‚ç”¨äºå…¨ç¨‹åºçš„ç®—æ³•ã€‚

è€ƒè™‘ä¸‹é¢è¿™æ ·ä¸€å°æ®µä»£ç ï¼Œæ˜¾ç„¶ï¼Œæˆ‘ä»¬å¿…é¡»è¦æœ‰è¿‡ç¨‹é—´çš„åˆ†æï¼Œæ‰èƒ½æœ‰æ›´å‡†ç¡®çš„åˆ†æç»“æœã€‚

```java
void foo(A a) {
    â€¦
    // ğ‘ğ‘¡(ğ‘) = ?
    b = a.bar();
    // ğ‘ğ‘¡(ğ‘) = ?    
    â€¦
}
```

å’Œè¿‡ç¨‹é—´åˆ†æç´§å¯†ç›¸å…³çš„æ˜¯è¿‡ç¨‹è°ƒç”¨çš„å¤„ç†ã€‚ä¹Ÿå°±æ˜¯ä¸ŠèŠ‚è¯¾æåˆ°çš„æœ€åä¸€æ¡ä¸Callæœ‰å…³çš„è§„åˆ™ã€‚

è¿™ä¸ªè§„åˆ™çœ‹èµ·æ¥å¤æ‚å¾—å¤šï¼Œæˆ‘ä»¬ä¸€ç‚¹ä¸€ç‚¹æ¥è§£æã€‚é¦–å…ˆï¼Œè¯·è¯»è€…ä»¬æš‚åœä¸€ä¸‹ï¼Œå›å¿†ä¸€èˆ¬è¯­è¨€å¦‚ä½•å¤„ç†è¿‡ç¨‹è°ƒç”¨ã€‚å³è¿‡ç¨‹è°ƒç”¨æ—¶åˆ°åº•å‘ç”Ÿäº†ä»€ä¹ˆã€‚

![](../.gitbook/assets/image-20201126230831572.png)

> â€‹ ä¸€ä¸ªå‚è€ƒç­”æ¡ˆï¼šä¿å­˜ç°åœºï¼Œæ„é€ è°ƒç”¨æ ˆå¸§ï¼Œä¼ é€’å‚æ•°ï¼Œè·³è½¬åˆ°ç›®æ ‡å‡½æ•°å¼€å§‹æ‰§è¡Œâ€¦â€¦ç›®æ ‡å‡½æ•°æ‰§è¡Œå®Œæ¯•è·³è½¬å›æ¥ï¼Œåä»é¢„å®šçš„ä½ç½®å–è¿”å›å€¼ï¼ˆè‹¥éœ€è¦ï¼‰ï¼Œæ¢å¤ç°åœºï¼Œç»§ç»­å¾€ä¸‹æ‰§è¡Œâ€¦â€¦

åœ¨é™æ€åˆ†æä¸­ï¼Œæˆ‘ä»¬æ›´å¤šåœ°å…³å¿ƒæ•°æ®æµï¼Œè€Œéæ§åˆ¶æµã€‚è€Œé’ˆå¯¹Javaï¼Œå¤„ç†å‡½æ•°è°ƒç”¨çš„æ•°æ®æµå¯ä»¥åˆ†ä¸ºä»¥ä¸‹å››ä¸ªéƒ¨åˆ†ï¼š

1. ç¡®å®šç›®æ ‡æ–¹æ³•ã€‚ç”¨ç¬¬7è¯¾ä»‹ç»è¿‡çš„Dispatchå‡½æ•°å®Œæˆã€‚
2. ä¼ receiver object

![](../.gitbook/assets/image-20201126184745576.png)

1. ä¼ å‚æ•°

![](../.gitbook/assets/image-20201126185008506.png)

1. ä¼ è¿”å›å€¼

![](../.gitbook/assets/image-20201126185233403.png)

å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹åº”è§„åˆ™ï¼Œåœ¨PFGä¸Šæ·»åŠ Edgeå®ç°è¿‡ç¨‹é—´ä¿¡æ¯çš„ä¼ é€’ã€‚å®Œæ•´çš„è§„åˆ™å¦‚ä¸‹ï¼š

![](../.gitbook/assets/image-20201126231116221.png)

### Detail-1

**Question: Why not add PFG edge ğ‘¥ â†’** $$ğ‘š_{ğ‘¡â„ğ‘–ğ‘ }$$**ï¼Ÿ**

é€šè¿‡è¿™ä¸¤ä¸ªå›¾å¯ä»¥ç›´è§‚åœ°è¯´æ˜åŸå› ï¼š

![](../.gitbook/assets/image-20201126231403264.png)

![](../.gitbook/assets/image-20201126231437769.png)

_åœ¨æ¯æ¬¡ç®—æ³•æ‰§è¡Œæ—¶ï¼Œ_$$o_i$$_æ˜¯ç¡®å®šçš„æŸä¸ªï¼ˆåªæœ‰ä¸€ä¸ªï¼‰å¯¹è±¡ï¼Œç„¶åé’ˆå¯¹è¿™ä¸ªå¯¹è±¡åšDispatchï¼Œèƒ½å¤Ÿæ‰¾åˆ°å¯¹åº”çš„å”¯ä¸€çš„receiver object._

### Detail-2

åƒä¹‹å‰ç”¨CHAåšè¿‡ç¨‹é—´åˆ†ææ—¶ä¸€æ ·ï¼Œæˆ‘ä»¬éœ€è¦å°†åˆ†æçš„è¿‡ç¨‹å’ŒCall graphæ„å»ºçš„è¿‡ç¨‹ç»“åˆèµ·æ¥ã€‚

![](../.gitbook/assets/image-20201126231722298.png)

ä¸åŒçš„æ˜¯ï¼Œè¿™æ¬¡æˆ‘ä»¬åªåˆ†æä»mainæ–¹æ³•ï¼ˆæˆ–è€…ä¸€èˆ¬æ€§åœ°è¯´ï¼Œç¨‹åºå…¥å£ï¼‰å¼€å§‹å¯è¾¾çš„éƒ¨åˆ†ã€‚åŸå› æœ‰äºŒï¼š

1. æå‡åˆ†æé€Ÿåº¦ã€‚å› ä¸ºæˆ‘ä»¬èƒ½å¤Ÿé¿å…åˆ†æä¸ä¼šè¢«æ‰§è¡Œåˆ°çš„æ­»ä»£ç ã€‚
2. æå‡åˆ†æç²¾åº¦ã€‚é¿å…äº†unreachableéƒ¨åˆ†çš„ä»£ç è°ƒç”¨reachableéƒ¨åˆ†æ–¹æ³•æ—¶å¯èƒ½å¼•èµ·çš„ç²¾åº¦ä¸‹é™ã€‚

![](../.gitbook/assets/image-20201126191225969.png)

## Algorithm: PA with Method Calls

æ¥ä¸‹æ¥ä»‹ç»ä¸€ä¸ªå…·ä½“çš„ã€æ˜“äºç†è§£å’Œå®ç°çš„ç®—æ³•ã€‚ç”±äºæŒ‡é’ˆåˆ†ææ˜¯é™æ€ç¨‹åºåˆ†æçš„åŸºç¡€ï¼Œç†è§£äº†è¿™ä¸ªçœ‹èµ·æ¥æ¯ç‡¥çš„ç®—æ³•åï¼Œæ›´å®¹æ˜“åœ¨é™æ€ç¨‹åºåˆ†æé¢†åŸŸè§¦ç±»æ—é€šã€‚~~è€Œä¸”æ®è¯´åé¢ä¸¤èŠ‚è¯¾ä¼šå­¦å¾—æ›´åŠ è½»æ¾~~

![](../.gitbook/assets/image-20201126191650221.png)

ç®—æ³•æ•´ä½“ä¸Šæ¥è¯´å’Œä¸Šä¸€èŠ‚è¯¾æ‰€ä»‹ç»çš„å¤§æ¡†æ¶ç›¸ä¼¼ï¼Œé»„è‰²æ ‡è®°çš„éƒ¨åˆ†æ˜¯è¿™æ¬¡æ–°åŠ å…¥çš„éƒ¨åˆ†ã€‚ç»¿è‰²éƒ¨åˆ†æ˜¯å¯¹æ–°çš„å…¨å±€å˜é‡çš„è¯´æ˜ï¼š

* Sé‡Œçš„statementså°±æ˜¯RMé‡Œmethodsçš„statementsï¼ˆè¯­å¥ï¼‰
* Call Graphå’ŒæŒ‡é’ˆé›†ä½œä¸ºæœ€åçš„è¾“å‡ºã€‚

### Function: AddReachable

AddReachableçš„ä½œç”¨æ˜¯ï¼š

* **è¾“å…¥å‚æ•°**mæ˜¯æœ€æ–°çš„å¯è¾¾æ–¹æ³•ã€‚
* å‡½æ•°ä¿®æ”¹ç»´æŠ¤å…¨å±€çš„RMã€Så’Œ$$S_m$$ï¼Œå¹¶å¤„ç†æ–°çš„æ–¹æ³•mä¸­çš„Newå’ŒAssignè¯­å¥ã€‚

![](../.gitbook/assets/image-20201126194125039.png)

### Detail-3

**Question: ä¸ºä»€ä¹ˆè¦æ£€æŸ¥l-&gt;mæ˜¯å¦åœ¨CGä¸­ï¼Œå³ä¸ºä»€ä¹ˆåŒæ ·çš„l-&gt;må¯èƒ½ä¸æ­¢ä¸€æ¬¡åœ°è¢«å¤„ç†ï¼Ÿ**

_lä»£è¡¨call siteã€‚å¯ä»¥ç”¨è¡Œå·ä½œä¸ºcall siteçš„labelã€‚_

> Answer: $$o_j, o_k$$åŒæ ·å¯èƒ½é€šè¿‡Dispatchè¿”å›åŒä¸€ä¸ªmã€‚

### Function:ProcessCall

ProcessCallçš„ä½œç”¨æ˜¯ï¼š

* è¾“å…¥çš„$$o_i$$æ˜¯xæ–°æŒ‡å‘çš„ç›®æ ‡ã€‚
* å‡½æ•°åœ¨å¯è¾¾çš„è¯­å¥é›†åˆSä¸­ï¼Œé€‰æ‹©æ‰€æœ‰ä¸xæœ‰å…³çš„è¿‡ç¨‹è°ƒç”¨ï¼Œåšä¹‹å‰æåˆ°çš„æ•°æ®æµç›¸å…³å››æ­¥å¤„ç†ï¼ˆç¡®å®šè¢«è°ƒç”¨æ–¹æ³•ã€ä¼ å¯¹è±¡ã€ä¼ å‚æ•°ï¼Œä¼ è¿”å›å€¼ï¼‰ã€‚

![](../.gitbook/assets/image-20201126195311513.png)

![](../.gitbook/assets/image-20201126195425756.png)

## Example

**åˆ©ç”¨ä¹‹å‰å­¦ä¹ çš„ç®—æ³•åˆ†æä»¥ä¸‹ä»£ç ï¼Œæ„å»ºCall graphå’ŒPFGã€‚**

```java
class A {
    static void main() {
        A a = new A();
        A b = new B();
        A c = b.foo(a);
    }
    A foo(A x) { â€¦ }  
}
class B extends A {
    A foo(A y) {
        A r = new A();
        return r;
    }
}
```

ç­”æ¡ˆå¦‚ä¸‹ï¼š

![](../.gitbook/assets/image-20201126201000426.png)

è¿™ä¸ªæµä¸æ•æ„Ÿçš„åˆ†æç®—æ³•åœ¨åˆ†æç²¾åº¦ä¸Šä»ç„¶å¯ä»¥æ”¹è¿›ã€‚æˆ‘ä»¬å°†åœ¨æ¥ä¸‹æ¥çš„è¯¾ç¨‹ä¸­å­¦ä¹ ç²¾åº¦æ›´é«˜çš„æµæ•æ„Ÿåˆ†æã€‚

## Key points

**The X You Need To Understand in This Lecture**

* Pointer analysis **rule for method call**
* **Algorithm** for inter-procedural pointer analysis 
* **On-the-fly call graph construction**

